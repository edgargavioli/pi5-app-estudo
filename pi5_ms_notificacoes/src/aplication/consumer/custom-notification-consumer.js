import { getChannel } from "../../infrastructure/messaging/rabbitmq.js";
import NotificationPersistence from "../../infrastructure/persistence/notification.js";
import UserPersistence from "../../infrastructure/persistence/user.js";

const notificationPersistence = new NotificationPersistence();
const userPersistence = new UserPersistence();

/**
 * Contextos personalizados para sess√µes baseado no conte√∫do
 */
function getSessaoContexto(sessaoData) {
    const conteudo = (sessaoData.conteudo || '').toLowerCase();
    const topicos = (sessaoData.topicos || []).join(' ').toLowerCase();
    const texto = `${conteudo} ${topicos}`;

    // Detectar contexto baseado no conte√∫do com contextos muito mais ricos
    if (texto.includes('matem√°tica') || texto.includes('c√°lculo') || texto.includes('√°lgebra') ||
        texto.includes('geometria') || texto.includes('trigonometria') || texto.includes('fun√ß√£o') ||
        texto.includes('equa√ß√£o') || texto.includes('logaritmo') || texto.includes('matriz')) {
        return {
            emoji: 'üî¢',
            materia: 'Matem√°tica',
            titulo: 'Sess√£o de Matem√°tica',
            tipo: 'exata',
            mensagemCriacao: 'Sua sess√£o de matem√°tica',
            dicaPreparacao: 'üí° Tenha sempre papel, l√°pis, borracha e calculadora √† m√£o!',
            preparacao: 'üî¢ Organize suas f√≥rmulas e prepare-se para os c√°lculos!',
            motivacao: 'Cada problema resolvido √© um passo para a excel√™ncia! üìê',
            ultimoAviso: '√â hora de dominar os n√∫meros!',
            mensagemInicio: 'Vamos dominar os n√∫meros!',
            ferramentas: ['Calculadora cient√≠fica', 'Papel milimetrado', 'R√©gua', 'Tabela de f√≥rmulas'],
            dicaPausa: 'Fa√ßa um exerc√≠cio f√≠sico leve - isso oxigena o c√©rebro para c√°lculos!'
        };
    }

    if (texto.includes('f√≠sica') || texto.includes('mec√¢nica') || texto.includes('eletricidade') ||
        texto.includes('√≥ptica') || texto.includes('termodin√¢mica') || texto.includes('ondas')) {
        return {
            emoji: '‚ö°',
            materia: 'F√≠sica',
            titulo: 'Sess√£o de F√≠sica',
            tipo: 'exata',
            mensagemCriacao: 'Sua sess√£o de f√≠sica',
            dicaPreparacao: 'üî¨ Prepare experimentos mentais e visualize os fen√¥menos!',
            preparacao: '‚ö° Visualize as leis da f√≠sica e prepare suas f√≥rmulas!',
            motivacao: 'A f√≠sica explica tudo ao nosso redor! Seja curioso(a)! üåå',
            ultimoAviso: 'As leis da f√≠sica te aguardam!',
            mensagemInicio: 'Hora de desvendar o universo!',
            ferramentas: ['Tabela de constantes', 'Calculadora', 'Diagramas', 'Simuladores'],
            dicaPausa: 'Observe a f√≠sica ao seu redor durante a pausa - a gravidade, o movimento!'
        };
    }

    if (texto.includes('qu√≠mica') || texto.includes('org√¢nica') || texto.includes('rea√ß√µes') ||
        texto.includes('√°tomo') || texto.includes('mol√©cula') || texto.includes('elemento')) {
        return {
            emoji: 'üß™',
            materia: 'Qu√≠mica',
            titulo: 'Sess√£o de Qu√≠mica',
            tipo: 'exata',
            mensagemCriacao: 'Sua sess√£o de qu√≠mica',
            dicaPreparacao: '‚öóÔ∏è Visualize as mol√©culas e suas intera√ß√µes!',
            preparacao: 'üß™ Organize sua tabela peri√≥dica e visualize as transforma√ß√µes!',
            motivacao: 'A qu√≠mica est√° em tudo! Transforme conhecimento em sucesso! ‚öóÔ∏è',
            ultimoAviso: 'As mol√©culas est√£o prontas para reagir!',
            mensagemInicio: 'Vamos criar algumas rea√ß√µes!',
            ferramentas: ['Tabela peri√≥dica', 'Modelos moleculares', 'Calculadora'],
            dicaPausa: 'Observe a qu√≠mica ao redor: a digest√£o, a fotoss√≠ntese!'
        };
    }

    if (texto.includes('hist√≥ria') || texto.includes('brasil') || texto.includes('mundo') ||
        texto.includes('guerra') || texto.includes('revolu√ß√£o') || texto.includes('imp√©rio')) {
        return {
            emoji: 'üèõÔ∏è',
            materia: 'Hist√≥ria',
            titulo: 'Sess√£o de Hist√≥ria',
            tipo: 'humana',
            mensagemCriacao: 'Sua sess√£o de hist√≥ria',
            dicaPreparacao: 'üìú Prepare cronologias e conecte eventos passados ao presente!',
            preparacao: 'üèõÔ∏è Organize suas cronologias e prepare sua m√°quina do tempo mental!',
            motivacao: 'Cada per√≠odo hist√≥rico tem li√ß√µes para o presente! üìú',
            ultimoAviso: 'A m√°quina do tempo est√° pronta!',
            mensagemInicio: 'Hora de viajar no tempo!',
            ferramentas: ['Atlas hist√≥rico', 'Linha do tempo', 'Mapas', 'Biografias'],
            dicaPausa: 'Reflita sobre como os eventos estudados ainda influenciam hoje!'
        };
    }

    if (texto.includes('portugu√™s') || texto.includes('literatura') || texto.includes('reda√ß√£o') ||
        texto.includes('gram√°tica') || texto.includes('texto') || texto.includes('interpreta√ß√£o')) {
        return {
            emoji: 'ÔøΩ',
            materia: 'Portugu√™s',
            titulo: 'Sess√£o de Portugu√™s',
            tipo: 'lingu√≠stica',
            mensagemCriacao: 'Sua sess√£o de portugu√™s',
            dicaPreparacao: '‚úçÔ∏è Prepare textos diversos e exercite sua express√£o!',
            preparacao: 'üìù Organize seus textos e prepare sua express√£o!',
            motivacao: 'Palavras s√£o poder! Use-as com maestria! ‚úçÔ∏è',
            ultimoAviso: '√â hora de dominar nossa l√≠ngua!',
            mensagemInicio: 'Vamos dominar nossa l√≠ngua!',
            ferramentas: ['Dicion√°rio completo', 'Gram√°tica', 'Textos diversos'],
            dicaPausa: 'Converse com algu√©m ou escreva seus pensamentos!'
        };
    }

    if (texto.includes('biologia') || texto.includes('c√©lula') || texto.includes('gen√©tica') ||
        texto.includes('evolu√ß√£o') || texto.includes('ecologia') || texto.includes('anatomia')) {
        return {
            emoji: 'üß¨',
            materia: 'Biologia',
            titulo: 'Sess√£o de Biologia',
            tipo: 'natural',
            mensagemCriacao: 'Sua sess√£o de biologia',
            dicaPreparacao: 'üî¨ Visualize processos celulares e conex√µes ecol√≥gicas!',
            preparacao: 'üß¨ Conecte-se com a vida ao seu redor!',
            motivacao: 'Voc√™ √© parte dessa teia incr√≠vel da vida! üåø',
            ultimoAviso: 'A vida em suas m√∫ltiplas formas te espera!',
            mensagemInicio: 'Vamos explorar os mist√©rios da vida!',
            ferramentas: ['Atlas biol√≥gico', 'Modelos celulares', 'Esquemas'],
            dicaPausa: 'Observe plantas, animais ou suas pr√≥prias c√©lulas trabalhando!'
        };
    }

    // Contexto padr√£o
    return {
        emoji: 'üìö',
        materia: 'Estudo Geral',
        titulo: 'Sess√£o de Estudo',
        tipo: 'geral',
        mensagemCriacao: 'Sua sess√£o de estudo',
        dicaPreparacao: 'üìñ Organize seus materiais e prepare sua mente!',
        preparacao: 'üìö Organize seus materiais e foque nos objetivos!',
        motivacao: 'Conhecimento √© o √∫nico tesouro que ningu√©m pode roubar! üíé',
        ultimoAviso: 'Sua mente est√° pronta para absorver conhecimento!',
        mensagemInicio: 'Vamos estudar com prop√≥sito e foco!',
        ferramentas: ['Material de estudo', 'Caderno', 'Marcadores'],
        dicaPausa: 'Reflita sobre o que aprendeu e como pode aplicar!'
    };
}

/**
 * Contextos para eventos baseado no tipo
 */
function getEventoContexto(tipoEvento) {
    const contextos = {
        'PROVA_SIMULADA': {
            emoji: 'üìù',
            titulo: 'Simulado',
            mensagemCriacao: 'Seu simulado',
            lembreteUrgente: 'Aten√ß√£o! Seu simulado',
            mensagemDia: '√â hora do seu simulado!',
            motivacao: 'Voc√™ treinou para isso! V√° com confian√ßa! üí™'
        },
        'EXAME_OFICIAL': {
            emoji: 'üéì',
            titulo: 'Exame',
            mensagemCriacao: 'Seu exame',
            lembreteUrgente: 'IMPORTANTE! Seu exame',
            mensagemDia: 'DIA DO EXAME!',
            motivacao: 'Todo seu esfor√ßo foi para este momento! Voc√™ consegue! üåü'
        },
        'VESTIBULAR': {
            emoji: 'üéØ',
            titulo: 'Vestibular',
            mensagemCriacao: 'Seu vestibular',
            lembreteUrgente: 'VESTIBULAR CHEGANDO!',
            mensagemDia: 'DIA DO VESTIBULAR!',
            motivacao: 'Este √© o momento que define seu futuro! Mande ver! üöÄ'
        },
        'ENEM': {
            emoji: 'üìö',
            titulo: 'ENEM',
            mensagemCriacao: 'Sua prova do ENEM',
            lembreteUrgente: 'ENEM se aproxima!',
            mensagemDia: 'DIA DO ENEM!',
            motivacao: 'Anos de estudo para este momento! Voc√™ est√° preparado(a)! üåà'
        },
        'CONCURSO': {
            emoji: '‚öñÔ∏è',
            titulo: 'Concurso',
            mensagemCriacao: 'Seu concurso',
            lembreteUrgente: 'CONCURSO em 3 dias!',
            mensagemDia: 'DIA DO CONCURSO!',
            motivacao: 'O cargo dos seus sonhos est√° ao seu alcance! Foco total! üíº'
        }
    };

    return contextos[tipoEvento] || {
        emoji: 'üìã',
        titulo: 'Evento',
        mensagemCriacao: 'Seu evento',
        lembreteUrgente: 'Seu evento',
        mensagemDia: 'Seu evento √© hoje!',
        motivacao: 'Boa sorte em seu evento! üçÄ'
    };
}

/**
 * Calcula dura√ß√£o da sess√£o em formato amig√°vel
 */
function calcularDuracaoSessao(sessaoData) {
    if (!sessaoData.tempoInicio || !sessaoData.tempoFim) {
        return 'Dura√ß√£o n√£o definida';
    }

    const inicio = new Date(sessaoData.tempoInicio);
    const fim = new Date(sessaoData.tempoFim);
    const duracaoMs = fim - inicio;
    const horas = Math.floor(duracaoMs / (1000 * 60 * 60));
    const minutos = Math.floor((duracaoMs % (1000 * 60 * 60)) / (1000 * 60));

    if (horas > 0) {
        return `${horas}h${minutos > 0 ? ` ${minutos}min` : ''}`;
    }
    return `${minutos}min`;
}

/**
 * Processa notifica√ß√µes de eventos criados
 */
async function processEventoNotificacao(msg, channel) {
    if (!msg) {
        console.error('Received null message for evento notification');
        return;
    }

    try {
        const message = JSON.parse(msg.content.toString());
        console.log('üì¨ Processing evento notification:', message);

        // A estrutura vem aninhada: message.data.data cont√©m os dados do evento
        const eventData = message.data.data || message.data;

        console.log('üîç Debug evento - eventData:', eventData);

        // Verificar se o usu√°rio existe
        let user;
        try {
            const userId = eventData.userId || 'user-default';
            if (userId && userId !== 'user-default') {
                console.log('üîç Buscando usu√°rio por ID:', userId);
                user = await userPersistence.findById(userId);
            } else {
                console.log('üîç Usando fallback para usu√°rio padr√£o');
                const defaultUsers = await userPersistence.getAll();
                user = defaultUsers[0];
            }
        } catch (error) {
            console.error(`‚ùå User not found:`, error.message);
            channel.ack(msg);
            return;
        }

        if (!user) {
            console.error('‚ùå Nenhum usu√°rio encontrado para criar notifica√ß√µes');
            channel.ack(msg);
            return;
        }

        // Gerar notifica√ß√µes personalizadas baseadas nas regras de neg√≥cio
        const agora = new Date();
        const dataEvento = new Date(eventData.data || eventData.dataEvento);
        const horarioEvento = new Date(eventData.horario);
        const diasAteEvento = Math.ceil((dataEvento - agora) / (1000 * 60 * 60 * 24)); const contextoEvento = getEventoContexto(eventData.tipo);

        // Notifica√ß√£o imediata
        await notificationPersistence.create({
            userId: user.id,
            type: `EVENTO_CRIADO`,
            entityId: eventData.eventoId || eventData.id,
            entityType: 'evento',
            entityData: eventData,
            scheduledFor: agora,
            message: `${contextoEvento.emoji} ${contextoEvento.titulo} Criado!`,
            title: `${contextoEvento.emoji} ${contextoEvento.titulo} Criado!`,
            body: `${contextoEvento.mensagemCriacao} "${eventData.titulo}" foi agendado${diasAteEvento > 0 ? ` para ${diasAteEvento} dias` : ' para hoje'}! üìÖ\nüìç Local: ${eventData.local}\n‚è∞ Hor√°rio: ${horarioEvento.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`,
            priority: 'normal'
        });

        // Lembrete 3 dias antes (se aplic√°vel)
        if (diasAteEvento > 3) {
            const lembrete3Dias = new Date(dataEvento.getTime() - 3 * 24 * 60 * 60 * 1000);
            await notificationPersistence.create({
                userId: user.id,
                type: `EVENTO_LEMBRETE_3_DIAS`,
                entityId: eventData.eventoId || eventData.id,
                entityType: 'evento',
                entityData: eventData,
                scheduledFor: lembrete3Dias,
                message: `‚è∞ Lembrete: ${contextoEvento.titulo} em 3 dias`,
                title: `‚è∞ Lembrete: ${contextoEvento.titulo} em 3 dias`,
                body: `${contextoEvento.lembreteUrgente} "${eventData.titulo}" acontece em 3 dias! üóìÔ∏è\nüìç Local: ${eventData.local}\n‚è∞ Hor√°rio: ${horarioEvento.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`,
                priority: 'high'
            });
        }

        // Lembrete no dia do evento
        if (diasAteEvento > 0) {
            const lembreteHoje = new Date(dataEvento.setHours(8, 0, 0, 0));
            await notificationPersistence.create({
                userId: user.id,
                type: `EVENTO_DIA`,
                entityId: eventData.eventoId || eventData.id,
                entityType: 'evento',
                entityData: eventData,
                scheduledFor: lembreteHoje,
                message: `üî• HOJE: ${contextoEvento.titulo}!`,
                title: `üî• HOJE: ${contextoEvento.titulo}!`,
                body: `${contextoEvento.mensagemDia} "${eventData.titulo}" √© HOJE! üéØ\nüìç ${eventData.local}\n‚è∞ ${horarioEvento.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}\n\n${contextoEvento.motivacao}`,
                priority: 'critical'
            });
        }

        console.log(`‚úÖ Notifica√ß√µes de evento criadas para ${eventData.titulo}`);
        channel.ack(msg);
    } catch (error) {
        console.error('Error processing evento notification:', error);
        channel.nack(msg, false, true);
    }
}/**
 * Processa notifica√ß√µes de sess√µes criadas
 */
async function processSessaoNotificacao(msg, channel) {
    if (!msg) {
        console.error('Received null message for sessao notification');
        return;
    }

    try {
        const message = JSON.parse(msg.content.toString());
        console.log('üìö Processing sessao notification:', message);

        // A estrutura vem aninhada: message.data.data cont√©m os dados da sess√£o
        const sessaoData = message.data.data || message.data;

        console.log('üîç Debug sessao - sessaoData:', sessaoData);

        // Verificar se o usu√°rio existe
        let user;
        try {
            const userId = sessaoData.userId || 'user-default';
            if (userId && userId !== 'user-default') {
                console.log('üîç Buscando usu√°rio por ID:', userId);
                user = await userPersistence.findById(userId);
            } else {
                console.log('üîç Usando fallback para usu√°rio padr√£o');
                const defaultUsers = await userPersistence.getAll();
                user = defaultUsers[0];
            }
        } catch (error) {
            console.error(`‚ùå User not found:`, error.message);
            channel.ack(msg);
            return;
        }

        if (!user) {
            console.error('‚ùå Nenhum usu√°rio encontrado para criar notifica√ß√µes');
            channel.ack(msg);
            return;
        }

        // Gerar notifica√ß√µes personalizadas para sess√µes
        const agora = new Date();
        const tempoInicio = sessaoData.tempoInicio ? new Date(sessaoData.tempoInicio) : null;
        const contextoSessao = getSessaoContexto(sessaoData);
        const duracao = calcularDuracaoSessao(sessaoData);

        // Notifica√ß√£o imediata de cria√ß√£o
        await notificationPersistence.create({
            userId: user.id,
            type: `SESSAO_CRIADA`,
            entityId: sessaoData.sessaoId || sessaoData.id,
            entityType: 'sessao',
            entityData: sessaoData,
            scheduledFor: agora,
            message: `${contextoSessao.emoji} ${contextoSessao.titulo} Organizada!`,
            title: `${contextoSessao.emoji} ${contextoSessao.titulo} Organizada!`,
            body: `${contextoSessao.mensagemCriacao} "${sessaoData.conteudo}" est√° planejada! üìö\n\nüìã Foco: ${sessaoData.topicos?.join(', ') || 'T√≥picos gerais'}\n‚è±Ô∏è ${duracao}${tempoInicio ? `\nüìÖ ${tempoInicio.toLocaleDateString('pt-BR')} √†s ${tempoInicio.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}` : ''}\n\n${contextoSessao.dicaPreparacao}`,
            priority: 'normal'
        });

        // Se h√° hor√°rio programado, criar lembretes
        if (tempoInicio && tempoInicio > agora) {
            const minutosAteInicio = Math.ceil((tempoInicio - agora) / (1000 * 60));

            // Lembrete de prepara√ß√£o (3h antes para sess√µes longas, 30min para curtas)
            const tempoPreparacao = duracao.includes('h') ? 3 * 60 : 30; // 3h ou 30min em minutos
            if (minutosAteInicio > tempoPreparacao) {
                const lembretePreparacao = new Date(tempoInicio.getTime() - tempoPreparacao * 60 * 1000);
                await notificationPersistence.create({
                    userId: user.id,
                    type: `SESSAO_PREPARACAO`,
                    entityId: sessaoData.sessaoId || sessaoData.id,
                    entityType: 'sessao',
                    entityData: sessaoData,
                    scheduledFor: lembretePreparacao,
                    message: `üéØ ${contextoSessao.emoji} Prepare-se: ${contextoSessao.titulo} se aproxima!`,
                    title: `üéØ ${contextoSessao.emoji} Prepare-se: ${contextoSessao.titulo} se aproxima!`,
                    body: `${contextoSessao.preparacao} "${sessaoData.conteudo}" ${duracao.includes('h') ? 'em 3 horas' : 'em 30 minutos'}! ÔøΩ\n\nüìã T√≥picos: ${sessaoData.topicos?.join(', ') || 'Revis√£o geral'}\n\nüí° ${contextoSessao.dicaPreparacao}`,
                    priority: 'high'
                });
            }

            // Lembrete 15 minutos antes (√∫ltimo aviso)
            if (minutosAteInicio > 15) {
                const quinzeMinutosAntes = new Date(tempoInicio.getTime() - 15 * 60 * 1000);
                await notificationPersistence.create({
                    userId: user.id,
                    type: `SESSAO_ULTIMO_AVISO`,
                    entityId: sessaoData.sessaoId || sessaoData.id,
                    entityType: 'sessao',
                    entityData: sessaoData,
                    scheduledFor: quinzeMinutosAntes,
                    message: `‚ö° ${contextoSessao.emoji} √öLTIMO AVISO: ${contextoSessao.titulo} em 15 min!`,
                    title: `‚ö° ${contextoSessao.emoji} √öLTIMO AVISO: ${contextoSessao.titulo} em 15 min!`,
                    body: `${contextoSessao.ultimoAviso} "${sessaoData.conteudo}" come√ßa em 15 minutos! ‚è∞\n\nüéØ Prepare-se mentalmente e organize seus materiais.\n\n${contextoSessao.motivacao}`,
                    priority: 'urgent'
                });
            }

            // Lembrete no momento exato da sess√£o
            await notificationPersistence.create({
                userId: user.id,
                type: `SESSAO_INICIO`,
                entityId: sessaoData.sessaoId || sessaoData.id,
                entityType: 'sessao',
                entityData: sessaoData,
                scheduledFor: tempoInicio,
                message: `üöÄ ${contextoSessao.emoji} AGORA: ${contextoSessao.titulo}!`,
                title: `üöÄ ${contextoSessao.emoji} AGORA: ${contextoSessao.titulo}!`,
                body: `${contextoSessao.mensagemInicio} "${sessaoData.conteudo}"! üéØ\n\nüìö Foco total em: ${sessaoData.topicos?.join(', ') || 'seus objetivos'}\n‚è±Ô∏è Dura√ß√£o: ${duracao}\n\n${contextoSessao.motivacao}`,
                priority: 'critical'
            });

            // Se a sess√£o for longa (>2h), adicionar lembrete de pausa
            if (sessaoData.tempoFim) {
                const fimSessao = new Date(sessaoData.tempoFim);
                const duracaoMs = fimSessao - tempoInicio;
                const duracaoHoras = duracaoMs / (1000 * 60 * 60);

                if (duracaoHoras > 2) {
                    const metadeSessao = new Date(tempoInicio.getTime() + duracaoMs / 2);
                    await notificationPersistence.create({
                        userId: user.id,
                        type: `SESSAO_PAUSA`,
                        entityId: sessaoData.sessaoId || sessaoData.id,
                        entityType: 'sessao',
                        entityData: sessaoData,
                        scheduledFor: metadeSessao,
                        message: `üßò‚Äç‚ôÄÔ∏è ${contextoSessao.emoji} Hora da Pausa Revigorante!`,
                        title: `üßò‚Äç‚ôÄÔ∏è ${contextoSessao.emoji} Hora da Pausa Revigorante!`,
                        body: `Voc√™ est√° no meio da sua sess√£o de ${contextoSessao.titulo.toLowerCase()}! üí™\n\nüéâ Parab√©ns pelo foco at√© aqui!\n\n‚è∏Ô∏è Fa√ßa uma pausa de 15-20 minutos:\n‚Ä¢ Alongue-se ü§∏‚Äç‚ôÄÔ∏è\n‚Ä¢ Hidrate-se üíß\n‚Ä¢ Respire ar puro üå±\n\n${contextoSessao.dicaPausa}\n\nDepois volte com tudo! üî•`,
                        priority: 'medium'
                    });
                }
            }
        }

        console.log(`‚úÖ Notifica√ß√µes de sess√£o criadas para ${sessaoData.conteudo}`);
        channel.ack(msg);
    } catch (error) {
        console.error('Error processing sessao notification:', error);
        channel.nack(msg, false, true);
    }
}

/**
 * Processa notifica√ß√µes de provas criadas
 */
async function processProvaNotificacao(msg, channel) {
    if (!msg) {
        console.error('Received null message for prova notification');
        return;
    }

    try {
        const message = JSON.parse(msg.content.toString());
        console.log('üìù Processing prova notification:', message);

        // A estrutura vem aninhada: message.data.data cont√©m os dados da prova
        const provaData = message.data.data || message.data;

        console.log('üîç Debug prova - provaData:', provaData);

        // Verificar se o usu√°rio existe
        let user;
        try {
            const userId = provaData.userId || 'user-default';
            if (userId && userId !== 'user-default') {
                console.log('üîç Buscando usu√°rio por ID:', userId);
                user = await userPersistence.findById(userId);
            } else {
                console.log('üîç Usando fallback para usu√°rio padr√£o');
                const defaultUsers = await userPersistence.getAll();
                user = defaultUsers[0];
            }
        } catch (error) {
            console.error(`‚ùå User not found:`, error.message);
            channel.ack(msg);
            return;
        }

        if (!user) {
            console.error('‚ùå Nenhum usu√°rio encontrado para criar notifica√ß√µes');
            channel.ack(msg);
            return;
        }

        // Gerar notifica√ß√µes personalizadas baseadas nas regras de neg√≥cio
        const agora = new Date();
        const dataProva = new Date(provaData.data || provaData.dataProva);
        const horarioProva = new Date(provaData.horario);
        const diasAteProva = Math.ceil((dataProva - agora) / (1000 * 60 * 60 * 24));

        // Contexto espec√≠fico para provas
        const contextoProva = {
            emoji: 'üìù',
            titulo: 'Prova',
            tipo: 'acad√™mica',
            mensagemCriacao: 'Sua prova',
            dicaPreparacao: 'üìö Organize seus materiais e revise os principais t√≥picos!',
            preparacao: 'üéØ Foque nos pontos principais e pratique exerc√≠cios!',
            motivacao: 'Voc√™ se preparou bem! Confie em si mesmo! üí™',
            ultimoAviso: '√â hoje! Confie no seu preparo!',
            mensagemInicio: 'Hora de mostrar o que sabe!',
            mensagemDia: 'HOJE √© o dia da sua prova!',
            lembreteUrgente: '√öltima revis√£o!'
        };

        // Notifica√ß√£o imediata
        await notificationPersistence.create({
            userId: user.id,
            type: `PROVA_CRIADA`,
            entityId: provaData.provaId || provaData.id,
            entityType: 'prova',
            entityData: provaData,
            scheduledFor: agora,
            message: `${contextoProva.emoji} ${contextoProva.titulo} Criada!`,
            title: `${contextoProva.emoji} ${contextoProva.titulo} Criada!`,
            body: `${contextoProva.mensagemCriacao} "${provaData.titulo}" foi agendada${diasAteProva > 0 ? ` para ${diasAteProva} dias` : ' para hoje'}! üìÖ\nüìç Local: ${provaData.local}\n‚è∞ Hor√°rio: ${horarioProva.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`,
            priority: 'normal'
        });

        // Lembrete 1 semana antes (se aplic√°vel)
        if (diasAteProva > 7) {
            const lembrete1Semana = new Date(dataProva.getTime() - 7 * 24 * 60 * 60 * 1000);
            await notificationPersistence.create({
                userId: user.id,
                type: `PROVA_LEMBRETE_1_SEMANA`,
                entityId: provaData.provaId || provaData.id,
                entityType: 'prova',
                entityData: provaData,
                scheduledFor: lembrete1Semana,
                message: `üìö Lembrete: Prova em 1 semana`,
                title: `üìö Lembrete: Prova em 1 semana`,
                body: `A prova "${provaData.titulo}" acontecer√° em 1 semana! üìÖ\nComece a intensificar seus estudos! üí™\nüìç Local: ${provaData.local}\n‚è∞ Hor√°rio: ${horarioProva.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`,
                priority: 'normal'
            });
        }

        // Lembrete 3 dias antes (se aplic√°vel)
        if (diasAteProva > 3) {
            const lembrete3Dias = new Date(dataProva.getTime() - 3 * 24 * 60 * 60 * 1000);
            await notificationPersistence.create({
                userId: user.id,
                type: `PROVA_LEMBRETE_3_DIAS`,
                entityId: provaData.provaId || provaData.id,
                entityType: 'prova',
                entityData: provaData,
                scheduledFor: lembrete3Dias,
                message: `‚è∞ Prova em 3 dias - Revis√£o final!`,
                title: `‚è∞ Prova em 3 dias - Revis√£o final!`,
                body: `${contextoProva.lembreteUrgente} A prova "${provaData.titulo}" √© em 3 dias! üéØ\nFa√ßa uma revis√£o geral dos t√≥picos principais!\nüìç Local: ${provaData.local}\n‚è∞ Hor√°rio: ${horarioProva.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`,
                priority: 'high'
            });
        }

        // Lembrete 1 dia antes
        if (diasAteProva > 1) {
            const lembrete1Dia = new Date(dataProva.getTime() - 1 * 24 * 60 * 60 * 1000);
            lembrete1Dia.setHours(20, 0, 0, 0); // 20h do dia anterior
            await notificationPersistence.create({
                userId: user.id,
                type: `PROVA_LEMBRETE_1_DIA`,
                entityId: provaData.provaId || provaData.id,
                entityType: 'prova',
                entityData: provaData,
                scheduledFor: lembrete1Dia,
                message: `üîî AMANH√É √© dia de prova!`,
                title: `üîî AMANH√É √© dia de prova!`,
                body: `A prova "${provaData.titulo}" √© AMANH√É! üìö\n‚úÖ Separe seus materiais\n‚úÖ Descanse bem\n‚úÖ Confie no seu preparo!\nüìç Local: ${provaData.local}\n‚è∞ Hor√°rio: ${horarioProva.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`,
                priority: 'high'
            });
        }

        // Lembrete no dia da prova
        if (diasAteProva >= 0) {
            const lembreteHoje = new Date(dataProva);
            lembreteHoje.setHours(7, 0, 0, 0); // 7h da manh√£ do dia da prova
            await notificationPersistence.create({
                userId: user.id,
                type: `PROVA_DIA`,
                entityId: provaData.provaId || provaData.id,
                entityType: 'prova',
                entityData: provaData,
                scheduledFor: lembreteHoje,
                message: `üéØ HOJE √© dia de prova!`,
                title: `üéØ HOJE √© dia de prova!`,
                body: `${contextoProva.mensagemDia} "${provaData.titulo}"! üî•\n\n${contextoProva.motivacao}\n\nüìç ${provaData.local}\n‚è∞ ${horarioProva.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}\n\nüçÄ Boa sorte!`,
                priority: 'critical'
            });
        }

        // Lembrete 1 hora antes da prova
        if (diasAteProva >= 0) {
            const lembrete1Hora = new Date(horarioProva.getTime() - 60 * 60 * 1000);
            await notificationPersistence.create({
                userId: user.id,
                type: `PROVA_1_HORA`,
                entityId: provaData.provaId || provaData.id,
                entityType: 'prova',
                entityData: provaData,
                scheduledFor: lembrete1Hora,
                message: `‚è∞ Prova em 1 hora!`,
                title: `‚è∞ Prova em 1 hora!`,
                body: `Sua prova "${provaData.titulo}" come√ßa em 1 hora! ‚è∞\n\n‚úÖ Verifique seus materiais\n‚úÖ Saia com anteced√™ncia\n‚úÖ Mantenha a calma!\n\nüìç ${provaData.local}\nüïê ${horarioProva.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`,
                priority: 'critical'
            });
        }

        console.log(`‚úÖ Notifica√ß√µes de prova criadas para ${provaData.titulo}`);
        channel.ack(msg);
    } catch (error) {
        console.error('Error processing prova notification:', error);
        channel.nack(msg, false, true);
    }
}

/**
 * Inicia o consumer para notifica√ß√µes customizadas
 */
export async function startCustomNotificationConsumer() {
    try {
        const channel = await getChannel();

        // Configurar filas simplificadas
        const EVENTO_NOTIFICATION_QUEUE = 'notificacao.evento.criado';
        const SESSAO_NOTIFICATION_QUEUE = 'notificacao.sessao.criada';
        const PROVA_NOTIFICATION_QUEUE = 'notificacao.prova.criada';

        // Declarar filas
        await channel.assertQueue(EVENTO_NOTIFICATION_QUEUE, { durable: true });
        await channel.assertQueue(SESSAO_NOTIFICATION_QUEUE, { durable: true });
        await channel.assertQueue(PROVA_NOTIFICATION_QUEUE, { durable: true });

        // Configurar exchange
        const EXCHANGE = 'pi5_events';
        await channel.assertExchange(EXCHANGE, 'topic', { durable: true });

        // Bind filas ao exchange
        await channel.bindQueue(EVENTO_NOTIFICATION_QUEUE, EXCHANGE, 'notificacao.evento.criado');
        await channel.bindQueue(SESSAO_NOTIFICATION_QUEUE, EXCHANGE, 'notificacao.sessao.criada');
        await channel.bindQueue(PROVA_NOTIFICATION_QUEUE, EXCHANGE, 'notificacao.prova.criada');

        // Configurar consumers
        await channel.consume(EVENTO_NOTIFICATION_QUEUE, (msg) => {
            processEventoNotificacao(msg, channel);
        }, { noAck: false });

        await channel.consume(SESSAO_NOTIFICATION_QUEUE, (msg) => {
            processSessaoNotificacao(msg, channel);
        }, { noAck: false });

        await channel.consume(PROVA_NOTIFICATION_QUEUE, (msg) => {
            processProvaNotificacao(msg, channel);
        }, { noAck: false });

        console.log('üöÄ Custom notification consumer started successfully');
        console.log(`üì¨ Listening for evento notifications on: ${EVENTO_NOTIFICATION_QUEUE}`);
        console.log(`üìö Listening for sessao notifications on: ${SESSAO_NOTIFICATION_QUEUE}`);
        console.log(`üìù Listening for prova notifications on: ${PROVA_NOTIFICATION_QUEUE}`);

    } catch (error) {
        console.error('Error starting custom notification consumer:', error);
        setTimeout(startCustomNotificationConsumer, 10000);
    }
}