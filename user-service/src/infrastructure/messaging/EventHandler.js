const logger = require('../utils/logger');
const GamificationService = require('../services/GamificationService');
const rabbitMQService = require('./RabbitMQService');

/**
 * Event Handler - Processa eventos recebidos via RabbitMQ
 * Respons√°vel por atualizar pontos, achievements e estat√≠sticas
 */
class EventHandler {
  constructor() {
    this.gamificationService = new GamificationService();
  }

  /**
   * Inicia o consumo de eventos
   */
  async startConsumers() {
    try {
      // Consumer para atualiza√ß√µes de pontos
      await rabbitMQService.consume(
        rabbitMQService.queues.USER_POINTS_UPDATES,
        this.handlePointsUpdate.bind(this)
      );

      logger.info('üéÆ Event Handlers iniciados com sucesso');
    } catch (error) {
      logger.error('‚ùå Erro ao iniciar Event Handlers', { error: error.message });
      throw error;
    }
  }

  /**
   * Processa eventos de atualiza√ß√£o de pontos
   */
  async handlePointsUpdate(message, rawMessage) {
    const { routingKey } = rawMessage.fields;
    
    try {
      logger.info('üéØ Processando evento de pontos', {
        routingKey,
        messageId: message.messageId
      });

      switch (routingKey) {
        case rabbitMQService.routingKeys.SESSAO_CRIADA:
          await this.handleSessaoCriada(message);
          break;
          
        case rabbitMQService.routingKeys.SESSAO_FINALIZADA:
          await this.handleSessaoFinalizada(message);
          break;
          
        case rabbitMQService.routingKeys.PROVA_FINALIZADA:
          await this.handleProvaFinalizada(message);
          break;
          
        default:
          logger.warn('‚ö†Ô∏è Routing key n√£o reconhecido', { routingKey });
      }

    } catch (error) {
      logger.error('‚ùå Erro ao processar evento de pontos', {
        error: error.message,
        messageId: message.messageId,
        routingKey
      });
      throw error; // Vai para dead letter queue
    }
  }

  /**
   * Processa cria√ß√£o de sess√£o de estudo
   */
  async handleSessaoCriada(message) {
    const { userId, sessaoId, materiaId, provaId } = message.data;

    logger.info('üìö Processando sess√£o criada', {
      userId,
      sessaoId,
      materiaId,
      provaId
    });

    // Gamifica√ß√£o: +10 XP por criar sess√£o
    const xpGanho = 10;
    
    await this.gamificationService.adicionarXP(userId, xpGanho, {
      tipo: 'SESSAO_CRIADA',
      referencia: sessaoId,
      descricao: 'Sess√£o de estudo criada'
    });

    // Publicar evento de pontos atualizados
    await this.publishPontosAtualizados(userId, xpGanho, 'SESSAO_CRIADA');

    logger.info('‚úÖ Sess√£o criada processada', {
      userId,
      xpGanho,
      sessaoId
    });
  }

  /**
   * Processa finaliza√ß√£o de sess√£o de estudo
   */
  async handleSessaoFinalizada(message) {
    const { 
      userId, 
      sessaoId, 
      materiaId, 
      provaId,
      tempoEstudo, // em minutos
      questoesAcertadas = 0,
      totalQuestoes = 0
    } = message.data;

    logger.info('üèÅ Processando sess√£o finalizada', {
      userId,
      sessaoId,
      tempoEstudo,
      questoesAcertadas,
      totalQuestoes
    });

    let xpTotal = 0;

    // 1. XP base por finalizar sess√£o
    const xpBase = 25;
    xpTotal += xpBase;

    // 2. XP por tempo de estudo (2 XP por minuto)
    const xpTempo = Math.floor(tempoEstudo * 2);
    xpTotal += xpTempo;

    // 3. XP por quest√µes acertadas (5 XP por quest√£o)
    const xpQuestoes = questoesAcertadas * 5;
    xpTotal += xpQuestoes;

    // 4. B√¥nus por desempenho (se houver quest√µes)
    let xpBonus = 0;
    if (totalQuestoes > 0) {
      const percentualAcerto = (questoesAcertadas / totalQuestoes) * 100;
      xpBonus = this.calcularBonusDesempenho(percentualAcerto);
      xpTotal += xpBonus;
    }

    await this.gamificationService.adicionarXP(userId, xpTotal, {
      tipo: 'SESSAO_FINALIZADA',
      referencia: sessaoId,
      descricao: `Sess√£o finalizada: ${tempoEstudo}min`,
      detalhes: {
        xpBase,
        xpTempo,
        xpQuestoes,
        xpBonus,
        tempoEstudo,
        questoesAcertadas,
        totalQuestoes
      }
    });

    // Verificar conquistas relacionadas a sess√µes
    await this.verificarConquistasSessao(userId, tempoEstudo);

    // Publicar evento de pontos atualizados
    await this.publishPontosAtualizados(userId, xpTotal, 'SESSAO_FINALIZADA');

    logger.info('‚úÖ Sess√£o finalizada processada', {
      userId,
      xpTotal,
      breakdown: { xpBase, xpTempo, xpQuestoes, xpBonus },
      sessaoId
    });
  }

  /**
   * Processa finaliza√ß√£o de prova
   */
  async handleProvaFinalizada(message) {
    const { 
      userId, 
      provaId, 
      questoesAcertadas,
      totalQuestoes,
      materiaId
    } = message.data;

    logger.info('üéì Processando prova finalizada', {
      userId,
      provaId,
      questoesAcertadas,
      totalQuestoes
    });

    let xpTotal = 0;

    // 1. XP base por finalizar prova
    const xpBase = 50;
    xpTotal += xpBase;

    // 2. XP por quest√µes acertadas
    const xpQuestoes = questoesAcertadas * 5;
    xpTotal += xpQuestoes;

    // 3. B√¥nus por desempenho
    const percentualAcerto = (questoesAcertadas / totalQuestoes) * 100;
    const xpBonus = this.calcularBonusDesempenho(percentualAcerto);
    xpTotal += xpBonus;

    await this.gamificationService.adicionarXP(userId, xpTotal, {
      tipo: 'PROVA_FINALIZADA',
      referencia: provaId,
      descricao: `Prova finalizada: ${questoesAcertadas}/${totalQuestoes}`,
      detalhes: {
        xpBase,
        xpQuestoes,
        xpBonus,
        percentualAcerto,
        questoesAcertadas,
        totalQuestoes
      }
    });

    // Verificar conquistas relacionadas a provas
    await this.verificarConquistasProva(userId, percentualAcerto);

    // Publicar evento de pontos atualizados
    await this.publishPontosAtualizados(userId, xpTotal, 'PROVA_FINALIZADA');

    logger.info('‚úÖ Prova finalizada processada', {
      userId,
      xpTotal,
      percentualAcerto,
      breakdown: { xpBase, xpQuestoes, xpBonus },
      provaId
    });
  }

  /**
   * Calcula b√¥nus de desempenho baseado no percentual de acerto
   */
  calcularBonusDesempenho(percentual) {
    if (percentual >= 90) return 30; // Excelente
    if (percentual >= 80) return 20; // Muito bom
    if (percentual >= 70) return 10; // Bom
    if (percentual >= 60) return 5;  // Regular
    return 0; // Abaixo de 60%
  }

  /**
   * Verifica conquistas relacionadas a sess√µes
   */
  async verificarConquistasSessao(userId, tempoEstudo) {
    try {
      const stats = await this.gamificationService.obterEstatisticas(userId);
      
      // Conquista: Primeira sess√£o
      if (stats.totalSessoes === 1) {
        await this.desbloquearConquista(userId, 'PRIMEIRA_SESSAO', 'Primeira sess√£o de estudo!');
      }
      
      // Conquista: Sess√£o longa (mais de 60 minutos)
      if (tempoEstudo >= 60) {
        await this.desbloquearConquista(userId, 'SESSAO_LONGA', 'Estudou por mais de 1 hora!');
      }
      
      // Conquista: 10 sess√µes
      if (stats.totalSessoes === 10) {
        await this.desbloquearConquista(userId, 'DEZ_SESSOES', '10 sess√µes de estudo!');
      }

    } catch (error) {
      logger.error('‚ùå Erro ao verificar conquistas de sess√£o', { 
        userId, 
        error: error.message 
      });
    }
  }

  /**
   * Verifica conquistas relacionadas a provas
   */
  async verificarConquistasProva(userId, percentualAcerto) {
    try {
      const stats = await this.gamificationService.obterEstatisticas(userId);
      
      // Conquista: Primeira prova
      if (stats.provasRealizadas === 1) {
        await this.desbloquearConquista(userId, 'PRIMEIRA_PROVA', 'Primeira prova realizada!');
      }
      
      // Conquista: Nota perfeita
      if (percentualAcerto === 100) {
        await this.desbloquearConquista(userId, 'NOTA_PERFEITA', 'Acertou 100% das quest√µes!');
      }
      
      // Conquista: 5 provas
      if (stats.provasRealizadas === 5) {
        await this.desbloquearConquista(userId, 'CINCO_PROVAS', '5 provas realizadas!');
      }

    } catch (error) {
      logger.error('‚ùå Erro ao verificar conquistas de prova', { 
        userId, 
        error: error.message 
      });
    }
  }

  /**
   * Desbloqueia uma conquista
   */
  async desbloquearConquista(userId, tipo, descricao) {
    try {
      const achievement = await this.gamificationService.desbloquearConquista(userId, {
        tipo,
        descricao,
        dataDesbloqueio: new Date()
      });

      if (achievement) {
        // Publicar evento de conquista desbloqueada
        await rabbitMQService.publish(
          rabbitMQService.routingKeys.CONQUISTA_DESBLOQUEADA,
          {
            data: {
              userId,
              conquista: achievement
            }
          }
        );

        logger.info('üèÜ Conquista desbloqueada', {
          userId,
          tipo,
          descricao
        });
      }

    } catch (error) {
      logger.error('‚ùå Erro ao desbloquear conquista', { 
        userId, 
        tipo, 
        error: error.message 
      });
    }
  }

  /**
   * Publica evento de pontos atualizados
   */
  async publishPontosAtualizados(userId, xpGanho, tipo) {
    try {
      const stats = await this.gamificationService.obterEstatisticas(userId);
      
      await rabbitMQService.publish(
        rabbitMQService.routingKeys.PONTOS_ATUALIZADOS,
        {
          data: {
            userId,
            xpGanho,
            xpTotal: stats.xpTotal,
            nivel: stats.nivel,
            progressoNivel: stats.progressoNivel,
            tipo
          }
        }
      );

      logger.debug('üìä Evento de pontos publicado', {
        userId,
        xpGanho,
        tipo
      });

    } catch (error) {
      logger.error('‚ùå Erro ao publicar pontos atualizados', { 
        userId, 
        error: error.message 
      });
    }
  }
}

module.exports = EventHandler; 